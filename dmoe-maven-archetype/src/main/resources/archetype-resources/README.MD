# ${projectName} - ${projectDescription}
This repository contains the `${projectName}` micro-decision service packaged as a micro-service JAR, and was originally generated by the **IBM Decision Manager Open Edition Maven Archetype** in order to ensure compliancee with Maven best practices. 

# Overview
**Update this section, describing this project, what it does, how it does it, it’s dependencies, test scenarios, etc…**

# How To Build
Once you have configured your local development environment, you need to perform a Maven `build` of the repository.  This repository is built using `mvn clean install` by either the CI/CD pipeline or on a local developer workstation.  If deploying artifacts to an enterprise Maven repository, please use `mvn clean deploy`, which requires configuration of the `distributionManagement` section of your project's parent pom.xml.  This project is also configured to generate container images automatically by utilizing the `container` profile, as in the following example:

```shell
mvn clean package -Pcontainer
```

# How To Run Infrastructure Services using Docker Compose
If you are currently running Docker or Rancher Desktop, you can utilize the docker compose configuration scripts in this section of the repository.  You can use `Docker Compose` to run the BAMOE images locally and the easiest way is to use `Rancher Desktop`.  Click [here](https://docs.rancherdesktop.io/getting-started/installation/) in order to get instructions on how to install Rancher Desktop in Docker mode.  

## Setup for Decisions (DMOE)
You will notice from the diagram below, there are only minimal infrastructure services required for DMOE applications.  You can choose to deploy `Maven` either a a container image or into your local `Artifactory` server as an off-line repository, or both.  If you wish to provide visual modeling capabilities to your developers or users, you can choose to deploy `BAMOE Canvas`.  No database or consoles are needed for decisions, however you can configure `Kafka` if your use cases include event-based decisioning.

![BAMOE Architecture for Decisions](/doc/images/architecture-decision.png)

## Setup for Process (PAMOE)
You will notice from the diagram below, there are additional infrastructure services required for PAMOE applications.  You can choose to deploy `Maven` either a a container image or into your local `Artifactory` server as an off-line repository, or both.  If you wish to provide visual modeling capabilities to your developers or users, you can choose to deploy `BAMOE Canvas`.  PAMOE applications require a database for process instance persistence, and you can deploy the DB and it's associated services as a container.  In addition, you can make the `BAMOE Management Console` available to your users as a container.  Finally, you can configure `Kafka` if your use case include event-based decisioning.

![BAMOE Architecture for Process](/doc/images/architecture-process.png)

## Maven Repository
For more information on how to properly setup Maven for local development, visit [Setting Up Maven](./maven/README.md).

## Container Images
All published BAMOE images can be pulled directly from Quay.io.  Here are the steps to follow:

1.  To install the basic BAMOE services, use the supplied `docker-compose.yml` in the `docker-compose` folder:

    ```bash
    docker compose up [optional]<service-name>
    ```

    where `<service-name>` equals the name of the service in compose file (optional, leaving this off will install all services in the `docker-compose.yml` file.)

    The images will start containers on the following ports:

    | Service                   | Port @ localhost              |
    | ------------------------- | ----------------------------- |
    | BAMOE Maven               | [9011](http://localhost:9020) |
    | BAMOE Canvas              | [9090](http://localhost:9090) |

2.  This repository uses internal infrastructure services to make demonstrations easier.  In order to utilize full extended infrastructure services, please refer to the [BAMOE Setup Asset](https://github.com/blulas/bamoe-setup).

#if (${runtime} == 'quarkus')
# How To Run in Development Mode
Quarkus comes with a built-in development mode, which means you can update the application sources, resources and configurations. The changes are automatically reflected in your running application. This is great to do development spanning UI and database as you see changes reflected immediately.  Dev mode enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect. This works too for resource files like the configuration property file. The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.  To run the service in Quarkus Dev Mode, use the following command:

```shell
mvn clean package quarkus:dev
```

Click [here](https://quarkus.io/guides/maven-tooling#dev-mode) for more information on Quarkus Dev Mode.
#end

# How To Test
There are various methods used to test this application, including calling the published REST API's using a tool like `curl` or `postman`.  Included in the `src/test/resources` folder is a set of sub-folders with example test cases.  You can use this in order to expand your collection of test cases.  

## Start with Swagger
In order to determine which REST endpoints have been published by the application, you simply need to start your application, either in Quarkus Dev Mode or via the published container image, and then navigate to the published swagger page at:  [CVS DMOE Demo - Swagger Page](http://localhost:8080/q/swagger-ui/).  

From there you will see the various published endpoints, which are coming from the `src/main/java/com/cvshealth/bblite/rules/l2l3validationrules/legacy/ServiceEndpoint.java` class.  The published swagger page provides the ability to `try it out` directly in the browser, for example:

![Example Swagger Page](/doc/images/swagger-example.png)

## Create Unit Tests
You are free to use any unit testing framework you choose, so long as it can call Java or REST API methods programmatically, such as:

- [Using Postman for Unit Testing](./src/test/resources/postman/README.md)
- [Using Curl for Unit Testing](./src/test/resources/curl/README.md)
- [Using Quarkus for Unit Testing](https://quarkus.io/guides/getting-started-testing)
- [Using JUnit for Unit Testing](https://junit.org/junit5/docs/current/user-guide/)

# Additional Information (*Appendicies*)
This repository is focused on business automation using [**IBM Business Automation Manager Open Editions**](https://www.ibm.com/docs/en/ibamoe/9.2.x) products, specifically the IBM build of [**Kogito**](https://kogito.kie.org/) known as **IBM Decison Manager Open Edition**.
- [**Apache Maven**](https://maven.apache.org/) is a free and open source software project management and comprehension tool. Based on  the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of  information. A **getting started guide** is available [here](http://maven.apache.org/guides/getting-started/).

- [**Git**](https://git-scm.com//) is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. There is a **handbook** available [here](https://guides.github.com/introduction/git-handbook/), as well as various **guides** for learning and working with Git available [here](https://guides.github.com/)

#if (${runtime} == 'quarkus')
- [**Quarkus**](https://quarkus.io/) - Traditional Java stacks were engineered for monolithic applications with long startup times and large memory requirements in a world where the cloud, containers, and Kubernetes did not exist. Java frameworks needed to evolve to meet the needs of this new world.  Quarkus was created to enable Java developers to create applications for a modern, cloud-native world. Quarkus is a Kubernetes-native Java framework tailored for GraalVM and HotSpot, crafted from best-of-breed Java libraries and standards. The goal is to make Java the leading platform in Kubernetes and serverless environments while offering developers a framework to address a wider range of distributed application architectures.  You can find a useful introdution to this technology at [**Getting Started with Quarkus**](https://quarkus.io/get-started/).
#end

#if (${runtime} == 'spring-boot')
- [**Spring Boot**](https://spring.io/) - Spring makes programming Java quicker, easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the world's most popular Java framework.  Spring’s flexible libraries are trusted by developers all over the world. Spring delivers delightful experiences to millions of end-users every day.  Spring’s flexible and comprehensive set of extensions and third-party libraries let developers build almost any application imaginable.  Spring Boot transforms how you approach Java programming tasks, radically streamlining your experience. Spring Boot combines necessities such as an application context and an auto-configured, embedded web server to make microservice development a cinch. To go even faster, you can combine Spring Boot with Spring Cloud’s rich set of supporting libraries, servers, patterns, and templates, to safely deploy entire microservices-based architectures into the cloud, in record time.  You can find a useful introdution to this technology at [**Getting Started with Spring Boot**](https://spring.io/quickstart).
#end